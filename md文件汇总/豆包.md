从零开始搭建 pnpm monorepo 环境步骤总结
一、前期准备：安装 pnpm
执行目录：任意目录（建议在终端默认目录）
执行命令：
bash
运行
npm install pnpm -g
命令作用：全局安装 pnpm 包管理工具，用于后续的 monorepo 环境搭建和依赖管理
二、初始化项目根目录
创建项目文件夹并进入
执行目录：你想存放项目的位置（如桌面）
执行命令：
bash
运行
mkdir my-monorepo && cd my-monorepo
命令作用：创建项目根目录并进入该目录
初始化根目录 package.json
执行目录：项目根目录（my-monorepo）
执行命令：
bash
运行
pnpm init
命令作用：生成初始的 package.json 文件
修改根目录 package.json
配置位置：根目录下的 package.json
需要复制的配置内容：
json
{
"private": true, // 添加此行，标识根目录为私有，不发布
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1"
},
"keywords": [],
"author": "",
"license": "ISC"
}
作用：设置根目录为私有，避免误发布
三、配置 pnpm 工作区
创建 pnpm-workspace.yaml
执行目录：项目根目录
执行命令：
bash
运行
touch pnpm-workspace.yaml
命令作用：创建 pnpm 工作区配置文件
配置工作区内容
配置位置：根目录下的 pnpm-workspace.yaml
需要复制的配置内容：
yaml
packages:

- 'play' # 组件测试环境目录
- 'docs' # 组件文档目录
- 'packages/_' # 所有组件包目录
  作用：声明 monorepo 管理的子项目目录范围
  四、创建子包目录及配置
  创建子包目录结构
  执行目录：项目根目录
  执行命令：
  bash
  运行
  mkdir -p packages/components packages/theme-chalk packages/utils play docs
  命令作用：创建各子包目录（components 组件包、theme-chalk 主题包、utils 工具包）及 play（测试环境）、docs（文档）目录
  初始化 components 子包
  执行目录：packages/components
  执行命令：
  bash
  运行
  pnpm init
  修改 package.json 内容：
  json
  {
  "name": "@cobyte-ui/components", // 子包名称，需唯一
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
  "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
  }
  初始化 theme-chalk 子包
  执行目录：packages/theme-chalk
  执行命令：
  bash
  运行
  pnpm init
  修改 package.json 内容：
  json
  {
  "name": "@cobyte-ui/theme-chalk",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
  "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
  }
  初始化 utils 子包
  执行目录：packages/utils
  执行命令：
  bash
  运行
  pnpm init
  修改 package.json 内容：
  json
  {
  "name": "@cobyte-ui/utils",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
  "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
  }
  五、安装子包依赖到根目录
  执行目录：项目根目录
  执行命令：
  bash
  运行
  pnpm install @cobyte-ui/components -w
  pnpm install @cobyte-ui/theme-chalk -w
  pnpm install @cobyte-ui/utils -w
  命令作用：将子包安装到根目录的 node_modules 中，-w 表示安装到根目录的 package.json
  安装后效果：根目录 package.json 会新增依赖：
  json
  {
  "dependencies": {
  "@cobyte-ui/components": "workspace:_",
  "@cobyte-ui/theme-chalk": "workspace:_",
  "@cobyte-ui/utils": "workspace:_"
  }
  }
  （workspace:_表示依赖本地工作区的包，发布时会自动替换为具体版本）
  六、安装开发依赖
  执行目录：项目根目录
  执行命令：
  bash
  运行
  pnpm install vue typescript @types/node -D -w
  命令作用：安装 vue（框架）、typescript（类型检查）、@types/node（node 类型定义）作为开发依赖，-D 表示开发环境依赖，-w 表示安装到根目录
  七、初始化 TypeScript 配置
  生成 tsconfig.json
  执行目录：项目根目录
  执行命令：
  bash
  运行
  pnpm tsc --init
  命令作用：生成 TypeScript 配置文件的初始模板
  创建 TypeScript 公共配置（tsconfig.base.json）
  执行目录：项目根目录
  执行命令：
  bash
  运行
  touch tsconfig.base.json
  配置内容：
  json
  {
  "compilerOptions": {
  "outDir": "dist",
  "target": "es2018",
  "module": "esnext",
  "baseUrl": ".",
  "sourceMap": false,
  "moduleResolution": "node",
  "allowJs": false,
  "strict": true,
  "noUnusedLocals": true,
  "resolveJsonModule": true,
  "allowSyntheticDefaultImports": true,
  "esModuleInterop": true,
  "removeComments": false,
  "rootDir": ".",
  "types": [],
  "paths": {
  "@cobyte-ui/_": ["packages/*"]
  }
  }
  }
  作用：定义各子项目共用的 TypeScript 编译规则
  创建组件包配置（tsconfig.web.json）
  执行目录：项目根目录
  执行命令：
  bash
  运行
  touch tsconfig.web.json
  配置内容：
  json
  {
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
  "composite": true,
  "jsx": "preserve",
  "lib": ["ES2018", "DOM", "DOM.Iterable"],
  "types": ["unplugin-vue-define-options"],
  "skipLibCheck": true
  },
  "include": ["packages"],
  "exclude": [
  "node_modules",
  "**/dist",
  "**/__tests__/**/*",
  "**/gulpfile.ts",
  "**/test-helper",
  "packages/test-utils",
  "**/*.md"
  ]
  }
  作用：配置组件包的 TypeScript 编译规则
  创建 play 环境配置（tsconfig.play.json）
  执行目录：项目根目录
  执行命令：
  bash
  运行
  touch tsconfig.play.json
  配置内容：
  json
  {
  "extends": "./tsconfig.web.json",
  "compilerOptions": {
  "allowJs": true,
  "lib": ["ESNext", "DOM", "DOM.Iterable"]
  },
  "include": [
  "packages",
  "typings/components.d.ts",
  "typings/env.d.ts",
  "play/main.ts",
  "play/env.d.ts",
  "play/src/**/*"
  ]
  }
  作用：配置 play 测试环境的 TypeScript 编译规则
  修改根目录 tsconfig.json
  配置位置：根目录下的 tsconfig.json
  配置内容：
  json
  {
  "files": [],
  "references": [
  { "path": "./tsconfig.web.json" },
  { "path": "./tsconfig.play.json" },
  { "path": "./tsconfig.vitest.json" } // 后续测试相关，暂时保留
  ]
  }
  作用：通过项目引用（project references）拆分 TypeScript 程序，提高编译效率
  八、搭建 play 测试环境
  创建 play 项目
  执行目录：项目根目录
  执行命令：
  bash
  运行
  pnpm create vite play --template vue-ts
  命令作用：使用 vite 创建一个 vue-ts 模板的 play 项目（用于测试组件）
  安装 play 项目依赖
  执行目录：play 目录
  执行命令：
  bash
  运行
  cd play && pnpm install
  命令作用：安装 play 项目所需的依赖
  配置根目录启动命令
  配置位置：根目录下的 package.json
  修改 scripts 部分：
  json
  {
  "scripts": {
  "dev": "pnpm -C play dev" // 添加此行
  }
  }
  作用：允许在根目录通过 pnpm run dev 直接启动 play 项目
  九、配置 TypeScript 类型检查脚本
  安装 npm-run-all 工具
  执行目录：项目根目录
  执行命令：
  bash
  运行
  pnpm install npm-run-all -D -w
  命令作用：安装用于并行 / 串行执行脚本的工具
  添加类型检查脚本
  配置位置：根目录下的 package.json
  修改 scripts 部分：
  json
  {
  "scripts": {
  "dev": "pnpm -C play dev",
  "typecheck:web": "vue-tsc -p tsconfig.web.json --composite false --noEmit",
  "typecheck:play": "vue-tsc -p tsconfig.play.json --composite false --noEmit",
  "typecheck:node": "tsc -p tsconfig.node.json --noEmit", // 假设存在 tsconfig.node.json
  "typecheck:vitest": "tsc -p tsconfig.vitest.json --noEmit", // 测试相关
  "typecheck": "run-p typecheck:web typecheck:play typecheck:node typecheck:vitest"
  }
  }
  作用：
  typecheck:xxx：分别对不同模块进行类型检查（只检查不编译）
  typecheck：通过 run-p 并行执行所有类型检查命令
  总结
  通过以上步骤，你已完成基于 pnpm 的 monorepo 环境搭建，包含项目结构划分、依赖管理、TypeScript 配置及测试环境搭建。后续可在 packages 目录开发组件，在 play 目录测试组件效果，并通过配置的脚本进行类型检查和项目启动。
